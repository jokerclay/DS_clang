# 树

**现实中的树根节点在下面，数据结构中的树根节点在上面**

* 树由两种元素组成
    * 节点: 节点当成**集合**, 根节点-> **全集**， 子节点 -> 全集中的**子集**, 所有子集的并集应该是全集
    * 边  : 边当成**关系**


# 树的定义
**选取某一边，可以看成链表**
**可以根据原有的链表，修改指针域的数量**

```cpp
// 链表
typedef struct Node {
    int data;
    struct Node *next;
} Node, *Tree
```

```cpp
// 三叉树
typedef struct Node {
    int data;
    struct Node *next[3];
} Node, *Tree
```

**树形结构是链表的一个扩展** <br>
**链表可以看成是树形结构的一个特例** <br>
**两者的差别仅仅在指针域上**  <br>


##  树的几个基本概念

1. 从上向下数: **树的深度**。从下向上数：**树的高度**
2. **节点的深度和高度**(不一定相等),<br>
   将某一个节点所在的子树拿出来，节点的高度 从 这个子树的底部向上，高度，从子树的根节点向下数，即为深度

3. **节点的度**: 某一个节点有几个子节点就是几度
4. **节点数量=边数+1**


## 二叉树
* 每个节点的度最多为 2
* 度 为 0 的节点 比度为 2 的节点多一个
* 任何 其他的树都可以转换成 二叉树
    * 如何 n 叉 数 转换成  二叉树? <br>
    **左孩子，右兄弟表示法**
## 二叉树的遍历
**前序遍历** :  **根 左 右** <br>
**中序遍历** :  **左 根 右** <br>
**后序遍历** :  **左 右 根** <br>

## 完全二叉树
**complete binnary tree** <br>
只有右半部分缺失
1. 编号为 i 的子节点(连续编号):  <br>
**左孩子编号： 2 * 1** <br>
**右孩子编号： 2 * 1 + 1** <br>

2. 可以用连续空间存储 (数组)

3. **完全二叉树基于计算(记住计算的规则的)，不基于记录(算法优化，记录式优化成计算式)**

    
## 二叉树 --  广义表
空树 --> ()  <br>
树中只有一个节点 A --> A 或者 A()  <br>
树中只有两个节点 A有一个子节点B --> A(B,) 或者 A(B)  <br>
树中只有三个节点 A有一个子节点B 一个子节点C  --> A(B,C) <br>

